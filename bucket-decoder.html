<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Bincode Decoder</title>
  <style>
    body {
      font-family: 'Courier New', monospace;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #1a1a1a;
      color: #e0e0e0;
    }

    .container {
      background: #2d2d2d;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .section {
      margin: 20px 0;
      padding: 15px;
      background: #363636;
      border-radius: 5px;
      border-left: 4px solid #4CAF50;
    }

    .hex-input {
      width: 100%;
      height: 100px;
      background: #1e1e1e;
      color: #e0e0e0;
      border: 1px solid #555;
      padding: 10px;
      font-family: monospace;
      border-radius: 4px;
    }

    .output {
      background: #1e1e1e;
      padding: 15px;
      border-radius: 4px;
      white-space: pre-wrap;
      font-family: monospace;
      border: 1px solid #555;
      max-height: 500px;
      overflow-y: auto;
    }

    button {
      background: #4CAF50;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-family: monospace;
    }

    button:hover {
      background: #45a049;
    }

    .error {
      color: #ff6b6b;
    }

    .value {
      color: #64b5f6;
    }

    .field {
      color: #81c784;
    }

    .timestamp {
      color: #ffb74d;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>ü¶Ä Rust BucketConfirmationState Decoder</h1>

    <div class="section">
      <h3>Hex Input</h3>
      <textarea class="hex-input" id="hexInput" placeholder="Paste your hexdump output here...">014a 92fc 74bf 1168 fb01
        0351 51fb 0303
        001b 1804 0218 85fc 74bf fc68 bf85 6874
        1901 0219 86fc 74bf fc68 bf86 6874 1a01
        021a 88fc 74bf fc68 bf88 6874 1b01 021b
        92fc 74bf fc68 bf92 6874 fc01 9e05 14b2</textarea>
      <br><br>
      <button onclick="decode()">üîç Decode Bincode Data</button>
    </div>

    <div class="section">
      <h3>Decoded Output</h3>
      <div class="output" id="output">Click "Decode Bincode Data" to see the parsed structures...</div>
    </div>
  </div>

  <script>
    class BincodeDecoder {
      constructor(bytes) {
        this.bytes = bytes;
        this.pos = 0;
      }

      readByte() {
        if (this.pos >= this.bytes.length) {
          throw new Error(`Unexpected end of data at position ${this.pos}`);
        }
        return this.bytes[this.pos++];
      }

      readVarint() {
        let result = 0;
        let shift = 0;
        while (true) {
          const byte = this.readByte();
          result |= (byte & 0x7F) << shift;
          if ((byte & 0x80) === 0) break;
          shift += 7;
        }
        return result;
      }

      readU32() {
        const bytes = [];
        for (let i = 0; i < 4; i++) {
          bytes.push(this.readByte());
        }
        return (bytes[3] << 24) | (bytes[2] << 16) | (bytes[1] << 8) | bytes[0];
      }

      readU64() {
        // For simplicity, reading as two 32-bit values (little endian)
        const low = this.readU32();
        const high = this.readU32();
        return (high * 0x100000000) + low;
      }

      readU16() {
        const low = this.readByte();
        const high = this.readByte();
        return (high << 8) | low;
      }

      readU8() {
        return this.readByte();
      }

      readVec() {
        const len = this.readVarint();
        const result = [];
        for (let i = 0; i < len; i++) {
          result.push(this.readByte());
        }
        return result;
      }

      readHashMap(keyReader, valueReader) {
        const len = this.readVarint();
        const result = new Map();
        for (let i = 0; i < len; i++) {
          const key = keyReader.call(this);
          const value = valueReader.call(this);
          result.set(key, value);
        }
        return result;
      }

      readBTreeMap(keyReader, valueReader) {
        const len = this.readVarint();
        const result = new Map();
        for (let i = 0; i < len; i++) {
          const key = keyReader.call(this);
          const value = valueReader.call(this);
          result.set(key, value);
        }
        return result;
      }

      remaining() {
        return this.bytes.length - this.pos;
      }
    }

    function parseHexDump(hexText) {
      // Parse hexdump format where each value is a 16-bit little-endian word
      const lines = hexText.trim().split('\n');
      const bytes = [];

      for (const line of lines) {
        // Remove the address prefix (e.g., "0000000 ")
        const hexPart = line.replace(/^[0-9a-f]+\s+/i, '').trim();
        if (!hexPart) continue;

        // Split into 16-bit words
        const words = hexPart.split(/\s+/).filter(w => w.length > 0);

        for (const word of words) {
          if (word.length === 4 && /^[0-9a-f]+$/i.test(word)) {
            // hexdump shows 16-bit words in little-endian format
            // "014a" means the word value is 0x4a01, stored as bytes [0x4a, 0x01]
            const lowByte = parseInt(word.substr(2, 2), 16);   // "4a" -> 0x4a
            const highByte = parseInt(word.substr(0, 2), 16);  // "01" -> 0x01  
            bytes.push(lowByte, highByte);
          }
        }
      }

      console.log(`Parsed ${bytes.length} bytes from hexdump`);
      console.log('First 10 bytes:', bytes.slice(0, 10).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
      return new Uint8Array(bytes);
    }

    function formatTimestamp(timestamp) {
      if (timestamp > 1000000000000) {
        // Likely microseconds
        return new Date(timestamp / 1000).toISOString() + ' (microseconds)';
      } else if (timestamp > 1000000000) {
        // Likely milliseconds or seconds
        return new Date(timestamp * 1000).toISOString() + ' (seconds)';
      } else {
        return `${timestamp} (raw value)`;
      }
    }

    function decode() {
      try {
        const hexInput = document.getElementById('hexInput').value;
        const bytes = parseHexDump(hexInput);
        console.log('Total bytes parsed:', bytes.length);
        console.log('First 20 bytes:', Array.from(bytes.slice(0, 20)).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));

        const decoder = new BincodeDecoder(bytes);

        let output = `<span class="field">üìã Parsing ChecksummedState...</span>\n`;
        output += `<span class="field">Total bytes</span>: <span class="value">${bytes.length}</span>\n\n`;

        // Parse ChecksummedState
        const dataLength = decoder.readVarint();
        output += `<span class="field">data length</span>: <span class="value">${dataLength}</span> bytes (pos: ${decoder.pos})\n`;

        if (dataLength > bytes.length - decoder.pos - 4) {
          throw new Error(`Data length ${dataLength} exceeds remaining bytes ${bytes.length - decoder.pos - 4}`);
        }

        const dataVec = [];
        for (let i = 0; i < dataLength; i++) {
          dataVec.push(decoder.readByte());
        }
        output += `<span class="field">data</span>: Vec&lt;u8&gt; with <span class="value">${dataVec.length}</span> bytes (pos: ${decoder.pos})\n`;

        const crc32 = decoder.readU32();
        output += `<span class="field">crc32c</span>: <span class="value">0x${crc32.toString(16).padStart(8, '0')}</span> (pos: ${decoder.pos})\n\n`;

        // Now parse the inner BucketConfirmationState
        const innerDecoder = new BincodeDecoder(new Uint8Array(dataVec));

        output += `<span class="field">ü™£ Parsing BucketConfirmationState...</span>\n`;
        output += `<span class="field">Inner data bytes</span>: <span class="value">${dataVec.length}</span>\n\n`;

        const version = innerDecoder.readVarint();
        output += `<span class="field">version</span>: <span class="value">${version}</span> (pos: ${innerDecoder.pos})\n`;

        const timestamp = innerDecoder.readVarint();
        output += `<span class="field">timestamp</span>: <span class="value">${timestamp}</span> ‚Üí <span class="timestamp">${formatTimestamp(timestamp)}</span> (pos: ${innerDecoder.pos})\n`;

        const bucketId = innerDecoder.readVarint();
        output += `<span class="field">bucket_id</span>: <span class="value">${bucketId}</span> (pos: ${innerDecoder.pos})\n\n`;

        // Parse HashMap<u16, PartitionConfirmationState>
        const mapLength = innerDecoder.readVarint();
        output += `<span class="field">partition_states length</span>: <span class="value">${mapLength}</span> (pos: ${innerDecoder.pos})\n\n`;

        const partitionStates = new Map();

        for (let i = 0; i < mapLength; i++) {
          output += `<span class="field">üìÇ Parsing Partition ${i + 1}/${mapLength}...</span>\n`;

          const partitionKey = innerDecoder.readVarint();
          output += `  <span class="field">partition key</span>: <span class="value">${partitionKey}</span> (pos: ${innerDecoder.pos})\n`;

          // Parse PartitionConfirmationState
          const partitionId = innerDecoder.readVarint();
          output += `  <span class="field">partition_id</span>: <span class="value">${partitionId}</span> (pos: ${innerDecoder.pos})\n`;

          const replicationFactor = innerDecoder.readVarint();
          output += `  <span class="field">replication_factor</span>: <span class="value">${replicationFactor}</span> (pos: ${innerDecoder.pos})\n`;

          const highestVersion = innerDecoder.readVarint();
          output += `  <span class="field">highest_version</span>: <span class="value">${highestVersion}</span> (pos: ${innerDecoder.pos})\n`;

          const confirmedWatermark = innerDecoder.readVarint(); // Arc<AtomicU64> serialized as u64
          output += `  <span class="field">confirmed_watermark</span>: <span class="value">${confirmedWatermark}</span> (pos: ${innerDecoder.pos})\n`;

          const unconfirmedEventsLength = innerDecoder.readVarint();
          output += `  <span class="field">unconfirmed_events length</span>: <span class="value">${unconfirmedEventsLength}</span> (pos: ${innerDecoder.pos})\n`;

          const unconfirmedEvents = new Map();
          for (let j = 0; j < unconfirmedEventsLength; j++) {
            const eventKey = innerDecoder.readVarint();
            const eventInfo = {
              version: innerDecoder.readVarint(),
              confirmation_count: innerDecoder.readVarint(),
              first_seen: innerDecoder.readVarint(),
              last_attempt: innerDecoder.readVarint(),
              attempts: innerDecoder.readVarint()
            };
            unconfirmedEvents.set(eventKey, eventInfo);

            output += `    <span class="field">üìù Event ${eventKey}:</span>\n`;
            output += `      <span class="field">version</span>: <span class="value">${eventInfo.version}</span>\n`;
            output += `      <span class="field">confirmation_count</span>: <span class="value">${eventInfo.confirmation_count}</span>\n`;
            output += `      <span class="field">first_seen</span>: <span class="value">${eventInfo.first_seen}</span> ‚Üí <span class="timestamp">${formatTimestamp(eventInfo.first_seen)}</span>\n`;
            output += `      <span class="field">last_attempt</span>: <span class="value">${eventInfo.last_attempt}</span> ‚Üí <span class="timestamp">${formatTimestamp(eventInfo.last_attempt)}</span>\n`;
            output += `      <span class="field">attempts</span>: <span class="value">${eventInfo.attempts}</span>\n`;
          }

          partitionStates.set(partitionKey, {
            partition_id: partitionId,
            replication_factor: replicationFactor,
            highest_version: highestVersion,
            confirmed_watermark: confirmedWatermark,
            unconfirmed_events: unconfirmedEvents
          });

          output += '\n';
        }

        if (innerDecoder.remaining() > 0) {
          output += `<span class="error">‚ö†Ô∏è  Warning: ${innerDecoder.remaining()} unread bytes remaining in inner data</span>\n`;
        }

        if (decoder.remaining() > 0) {
          output += `<span class="error">‚ö†Ô∏è  Warning: ${decoder.remaining()} unread bytes remaining in outer data</span>\n`;
        }

        document.getElementById('output').innerHTML = output;

      } catch (error) {
        console.error('Decode error:', error);
        document.getElementById('output').innerHTML = `<span class="error">‚ùå Error: ${error.message}\n\nStack trace:\n${error.stack}</span>`;
      }
    }
  </script>
</body>

</html>